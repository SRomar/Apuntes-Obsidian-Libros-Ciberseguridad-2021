If care is not taken to devise rules that accurately allow access based on the correct **HTTP methods** and URL paths, this may lead to unauthorized access. For example, if an administrative function to create a new user uses the POST methods, the platform may have a deny rule that disallows the POST methods and allows all other methods. However,if the application-level code does not verify that all request for this function are in fact using POST methods, an attacker may be able to circumvent the control by submitting the same request using the GET methods. Since most application-level APIs retrieving request parameters are agnostic as to the request method, the attacker can simply supply the required parameters within the URL query string of the GET request to make unauthorized use of the function.

What is more surprising, on the face of it,  **is that application can still be vulnerable even if the platform-level rule denies access to both the GET and POST methods.** This happens because requests using other HTTP methods may ultimately be **handled by the same application code** that handles GET and POST request. One example of this is the HEAD methods. According to specifications, servers should respond to a HEAD request with the same headers they would use to respond to the corresponding GET request, but with no message body. Hence, GET handler and just return the HTTP headers that are generated. GET request can often be used to perform sensitive actions, either because the application itself uses GET request for this purpose (contrary to specifications) or because HEAD request to add an administrative user account, he or she can live without receiving any message body in the response.